<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Hello World
</p>
<h1>Hello World</h1>
<p>
We will start with a very simple blade,
<a href="HelloWorldBlade.java">HelloWorldBlade</a>:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.*;
import org.agilewiki.jactor2.core.facilities.*;
import org.agilewiki.jactor2.core.messages.*;
import org.agilewiki.jactor2.core.reactors.*;

public class HelloWorldBlade extends BladeBase {

    public HelloWorldBlade(final Reactor _reactor) throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;String&gt; getGreetingAReq() {
        return new AsyncRequest&lt;String&gt;(getReactor()) {
            @Override
            public void processAsyncRequest() throws Exception {
                processAsyncResponse("Hello world!");
            }
        };
    }
}
</pre>
<p>
There is a lot here to discuss, but we should first note that this blade is completely unjustifiable,
except that is is simple enough to use as a first example.
</p>
<blockquote>
<h3>
<a href="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/blades/BladeBase.html">BladeBase</a>
</h3>
<p>
For HelloWorldBlade to be an blade, it must implement
<a href="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/blades/Blade.html">Blade</a>
so that the getReactor method can be used to access the blade's reactor.
The easy way to do this is to extend BladeBase.
</p>
<h3>
<a href ="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/reactors/Reactor.html">Reactor</a>
</h3>
<p>
A reactor is a light weight thread that processes messages for one or more blades.
A blade can not function without one.
So in the constructor of HelloWorldBlade, the method BladeBase.initialize is used to assign
the blade's reactor.
</p>
<h3>
<a href="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/messages/AsyncRequest.html">AsyncRequest&lt;RESPONSE_TYPE&gt;</a>
</h3>
<p>
Request has an abstract method, processAsyncRequest, which is called on the thread of the actor which implements the subclass of ASyncRequest.
The HelloWorldActor.getGreetingAReq method creates a request that simply returns the string "Hello world!".
</p>
</blockquote>
<p>
Here then is a program that exercises HelloWorldBlade, <a href="HelloWorld.java">HelloWorld</a>:
</p>
<pre>
import org.agilewiki.jactor2.core.*;
import org.agilewiki.jactor2.core.threading.*;
import org.agilewiki.jactor2.core.messaging.*;
import org.agilewiki.jactor2.core.processing.*;

public class HelloWorld {
    public static void main(final String[] _args) throws Exception {
        ModuleContext context = new ModuleContext();
        try {
            NonBlockingMessageProcessor messageProcessor = 
                    new NonBlockingMessageProcessor(context);
            HelloWorldActor helloWorldActor = 
                    new HelloWorldActor(messageProcessor);
            AsyncRequest<String> getGreetingAReq = helloWorldActor.getGreetingAReq();
            String response = getGreetingAReq.call();
            System.out.println(response);
        } finally {
            context.close();
        }
    }
}
</pre>
<p>
Again, there are a number of items to discus.
</p>
<blockquote>
<h3>
<a href="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/threading/ModuleContext.html">ModuleContext</a>
</h3>
<p>
A module context provides several services. It manages a thread pool, a table of properties and a list of 
AutoClosable objects that are to be closed when the context is closed.
A program can have one or more modules, each with its own life-cycle. And, of course, a program
will not exit normally until all the modules have been closed.
</p>
<h3>
<a href="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/processing/NonBlockingMessageProcessor.html">NonBlockingMessageProcessor</a>
</h3>
<p>
A NonBlockingMessageProcessor is one of several types of message processors.
NonBlockingMessageProcessor is the default message processor used by most actors. 
But it should not be used when an actor blocks for I/O or performs extensive computations.
In HelowWorld, the HelloWorldActor is created with a NonBlockingMessageProcessor.
</p>
<h3>
<a href="http://laforge49.github.io/JActor2/api/org/agilewiki/jactor2/core/messaging/RequestBase.html#call()">call</a>
</h3>
<p>
JActor is lock-free <strong>except</strong> for the call method.
This method creates passes a request to the actor that implemented that request object,
and blocks the current thread until a response is received.
HelloWorld invokes getGreetingAReq.call to access the greeting provided by the HellowWorldActor.
In general, call is only invoked by foreign threads, like the main thread in this case.
</p>
</blockquote>
<p>
Time to run this.
</p>
<pre>
C:\GitHub\JActor2docs\tutorials\core>test.bat HelloWorld

C:\GitHub\JActor2docs\tutorials\core>del *.class

C:GitHub\JActor2docs\tutorials\core>javac -classpath jactor2-core-0.1.0.jar;slf4
j-api-1.7.5.jar *.java

C:\GitHub\JActor2docs\tutorials\core>java -classpath jactor2-core-0.1.0.jar;slf4
j-api-1.7.5.jar;slf4j-simple-1.7.5.jar;. HelloWorld
Hello world!

C:\GitHub\JActor2docs\tutorials\core>
</pre>
</body>
</html>
