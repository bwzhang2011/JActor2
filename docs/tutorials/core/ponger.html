<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Ponger
</p>
<h1>Ponger - SyncRequest</h1>
<a href="Ponger.java">Ponger</a>
is a very simple blade. It has a synchronous request, pingSReq.
This request returns the number of times it has been called:
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class Ponger extends BladeBase {
    private long count = 0;
    
    public Ponger(final Reactor _reactor) throws Exception {
        initialize(_reactor);
    }

    public SyncRequest&lt;Long&gt; pingSReq() {
        return new SyncBladeRequest&lt;Long&gt;() {
            @Override
            protected Long processSyncRequest() throws Exception {
                count += 1;
                return count;
            }
        };
    }
}
</pre>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/BladeBase.html">BladeBase</a>
</h3>
<pre>
public class Ponger extends BladeBase {
    ...
}
</pre>
<p>
BladeBase implements the Blade interface and provides a number of methods and nested
classes for use when implementing a Blade.
</p>
<h3>
Thread Safety
</h3>
<pre>
    private long count = 0;
</pre>
<p>
The member variable count is private and the only means of updating it is through a
request. Which makes it thread-safe.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/BladeBase.html#initialize(org.agilewiki.jactor2.core.reactors.Reactor)">BladeBase.initialize</a>
</h3>
<pre>
    public Ponger(final Reactor _reactor) throws Exception {
        initialize(_reactor);
    }
</pre>
<p>
Every blade needs a reactor before it can send or receive messages.
And once set, a blade can not be assigned a different reactor.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/blades/BladeBase.SyncBladeRequest.html">SyncBladeRequest&lt;RESPONSE_TYPE&gt;</a>
</h3>
<pre>
    public SyncRequest&lt;Long&gt; pingSReq() {
        return new SyncBladeRequest&lt;Long&gt;() {
            ...
        };
    }
</pre>
<p>
SyncBladeRequest is a BladeBase nested class that extends
<a href="../../api/org/agilewiki/jactor2/core/messages/SyncRequest.html">SyncRequest&lt;RESPONSE_TYPE&gt;</a>.
The pingSReq method returns a non-reusable instance of SyncRequest for accessing the state of the blade.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/messages/SyncRequest.html#processSyncRequest()">SyncRequest.processSyncRequest</a>
</h3>
<pre>
            @Override
            protected Long processSyncRequest() throws Exception {
                count += 1;
                return count;
            }
</pre>
<p>
The processSyncRequest method is called when the SyncRequest is invoked.
But it runs on the thread of the reactor assigned to the blade,
regardless of which thread was used to invoke the SyncRequest.
This method is used to access and/or update the state of the blade and to return a result.
</p>
<h2>
<a href="PongerValidator.java">PongerValidator</a>
</h2>
<p>
PongerValidator is a simple program that exercises Ponger:
</p>
<pre>
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class PongerValidator {
    public static void main(final String[] _args) throws Exception {
        Facility facility = new Facility();
        try {
            Ponger ponger = new Ponger(new NonBlockingReactor(facility));
            long i = 0;
            while (i < 10) {
                i++;
                long j = ponger.pingSReq().call();
                if (i != j)
                    throw new IllegalStateException("unexpected result");
            }
        } finally {
            facility.close();
        }
    }
}
</pre>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/facilities/Facility.html">Facility</a>
</h3>
<pre>
        Facility facility = new Facility();
        try {
            ...
        } finally {
            facility.close();
        }
</pre>
<p>
One or more facilities are always needed when using JActor.
And they must be closed for the program to exit normally.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/reactors/NonBlockingReactor.html">NonBlockingReactor</a>
</h3>
<pre>
            Ponger ponger = new Ponger(new NonBlockingReactor(facility));
</pre>
<p>
Blades generally use non-blocking reactors, but only if they do not block the thread for I/O, intense computation 
or any other reason.
</p>
<h3>
<a href="../../api/org/agilewiki/jactor2/core/messages/RequestBase.html#call()">call</a>
</h3>
<pre>
            long i = 0;
            while (i < 10) {
                i++;
                long j = ponger.pingSReq().call();
                if (i != j)
                    throw new IllegalStateException("unexpected result");
            }
</pre>
<p>
The call method will return the result from invoking a request, but can not be used from within a blade.
This method blocks the main thread until a result is received.
</p>
</body>
</html>
