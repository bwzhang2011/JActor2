<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; DiningPhilosophers
</p>
<h1>DiningPhilosophers - Pending Responses</h1>
<p>
The <a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining Philosophers</a> 
is a classic problem in concurrency.
Five philosophers sit at a table with 5 place settings and 5 forks. 
Spaghetti is served, but the philosophers will only eat when they have two forks.
The philosophers, once they have both forks, will eat a meal and then return the forks to the table before eating again.
Our objective here is to see how fast our philosophers can eat.
</p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Dining_philosophers.png/578px-Dining_philosophers.png"></a>
<h2>DiningPhilosopher</h2>
<p>
As we are implementing our solution to this problem without built-in delays or locks, we will use 
hungry philosophers who will eat as soon as they get both a left and right fork, put the forks back on the
table and then immediately try to pick up their forks and eat again. This differs a bit from other solutions where the philosophers
take time out to think when they can not immediately get a fork. 
<a href="DiningPhilosopher.java">Here</a> is the code used to model a hungry philosopher:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class DiningPhilosopher extends BladeBase {
    public DiningPhilosopher(final Reactor _reactor) throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;Integer&gt; feastAReq(final DiningTable _diningTable, final int _seat)
            throws Exception {
        return new AsyncBladeRequest&lt;Integer&gt;() {
            final AsyncResponseProcessor&lt;Integer&gt; dis = this;
            
            private int mealsEaten;
            private AsyncResponseProcessor&lt;Void&gt; ateResponseProcessor;
            private AsyncResponseProcessor&lt;Boolean&gt; eatResponseProcessor;
            
            @Override
            protected void processAsyncRequest() throws Exception {
                ateResponseProcessor = new AsyncResponseProcessor&lt;Void&gt;() {
                    @Override
                    public void processAsyncResponse(final Void _ateResponse) throws Exception {
                        AsyncRequest&lt;Boolean&gt; eatAReq = _diningTable.eatAReq(_seat);
                        send(eatAReq, eatResponseProcessor);
                    }
                };
                eatResponseProcessor = new AsyncResponseProcessor&lt;Boolean&gt;() {
                    @Override
                    public void processAsyncResponse(final Boolean _eatResponse) throws Exception {
                        if (!_eatResponse) {
                            dis.processAsyncResponse(mealsEaten);
                            return;
                        }
                        mealsEaten++;
                        SyncRequest&lt;Void&gt; ateSReq = _diningTable.ateSReq(_seat);
                        send(ateSReq, ateResponseProcessor);
                    }
                };
                AsyncRequest&lt;Boolean&gt; eatAReq = _diningTable.eatAReq(_seat);
                send(eatAReq, eatResponseProcessor);
            }
        };
    }
}
</pre>
<p>
Each philosopher has a seat at the table, and the seats are numbered from 0 through 4.
The DiningPhilosopher class implements a single public request, feastAReq, 
which returns the number of meals the philosopher ate once all the spaghetti was eaten.
</p>
<p>
The feast request executes a simple loop, calling eatAReq and ateSReq until eatAReq returns a result
of false--which indicates that there is no more food to eat.
</p>
<h2>DiningTable</h2>
<p>
The DiningTable is responsible for managing the forks and serving up the spaghetti.
But it also does not respond to an eat request until either both forks are available or
there is no more spaghetti, whichever comes first.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class DiningTable extends BladeBase {
    public final int seats;
    public final int meals;
    
    private int mealsEaten;
    private int[] forkUsage;
    private AsyncResponseProcessor&lt;Boolean&gt;[] pendingResponses;

    public DiningTable(final Reactor _reactor, final int _seats, final int _meals) 
            throws Exception {
        initialize(_reactor);
        seats = _seats;
        meals = _meals;
        forkUsage = new int[seats];
        int i = 0;
        while (i < seats) {
            forkUsage[i] = -1;
            i++;
        }
        pendingResponses = new AsyncResponseProcessor[seats];
    }
    
    private int leftFork(final int _seat) {
        return _seat;
    }
    
    private int rightFork(final int _seat) {
        return (_seat + 1) % seats;
    }
    
    private boolean isForkAvailable(final int _seat) {
        return forkUsage[_seat] == -1;
    }
    
    private boolean getForks(final int _seat) {
        int leftFork = leftFork(_seat);
        int rightFork = rightFork(_seat);
        if (isForkAvailable(leftFork) && isForkAvailable(rightFork)) {
            forkUsage[leftFork] = _seat;
            forkUsage[rightFork] = _seat;
            return true;
        }
        return false;
    }
    
    public AsyncRequest&lt;Boolean&gt; eatAReq(final int _seat) {
        return new AsyncBladeRequest&lt;Boolean&gt;() {
            final AsyncResponseProcessor&lt;Boolean&gt; dis = this;
            
            @Override
            protected void processAsyncRequest() throws Exception {
                if (mealsEaten == meals) {
                    dis.processAsyncResponse(false);
                    return;
                }
                
                if (getForks(_seat)) {
                    mealsEaten++;
                    dis.processAsyncResponse(true);
                    if (mealsEaten == meals) {
                        int i = 0;
                        while (i < seats) {
                            AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[i];
                            if (pendingResponse != null) {
                                pendingResponse.processAsyncResponse(false);
                            }
                            i++;
                        }
                    }
                    return;
                }
                
                pendingResponses[_seat] = dis;
            }
        };
    }
    
    private int leftSeat(final int _fork) {
        return (_fork + seats - 1) % seats;
    }
    
    private int rightSeat(final int _fork) {
        return _fork;
    }

    private void notice(final int _seat) throws Exception {
        AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[_seat];
        if (pendingResponse == null)
            return;
        if (!getForks(_seat))
            return;
        pendingResponses[_seat] = null;
        if (mealsEaten == meals)
            pendingResponse.processAsyncResponse(true);
        mealsEaten++;
        pendingResponse.processAsyncResponse(true);
    }
    
    public SyncRequest&ls;Void&gt; ateSReq(final int _seat) {
        return new SyncBladeRequest&ls;Void&gt;() {
            @Override
            protected Void processSyncRequest() throws Exception {
                int leftFork = leftFork(_seat);
                int rightFork = rightFork(_seat);
                forkUsage[leftFork] = -1;
                forkUsage[rightFork] = -1;
                notice(leftSeat(leftFork));
                notice(rightSeat(rightFork));
                return null;
            }
        };
    }
}
</pre>
<h3>eatAReq</h3>
<pre>
    public AsyncRequest&lt;Boolean&gt; eatAReq(final int _seat) {
        return new AsyncBladeRequest&lt;Boolean&gt;() {
            final AsyncResponseProcessor&lt;Boolean&gt; dis = this;
            
            @Override
            protected void processAsyncRequest() throws Exception {
                if (mealsEaten == meals) {
                    dis.processAsyncResponse(false);
                    return;
                }
                
                if (getForks(_seat)) {
                    mealsEaten++;
                    dis.processAsyncResponse(true);
                    if (mealsEaten == meals) {
                        int i = 0;
                        while (i < seats) {
                            AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[i];
                            if (pendingResponse != null) {
                                pendingResponse.processAsyncResponse(false);
                            }
                            i++;
                        }
                    }
                    return;
                }
                
                pendingResponses[_seat] = dis;
            }
        };
    }
</pre>
<p>
When an eat request is received but there are no more meals to serve, 
a response of false is passed back.
</p>
<p>
If there are more meals remaining and both forks are acquired, then: 
</p>
<ol>
<li>The number of meals eaten is incremented by 1.</li>
<li>A response of true is passed back to the requesting philosopher.</li>
<li>And if that was the last available meal, then all pending eat requests return a response of false.</li>
</ol>
<p>
Otherwise, the response is left pending until either there is no more spaghetti or both forks become available.
</p>
<h3>ateSReq</h3>
<pre>
    public SyncRequest&ls;Void&gt; ateSReq(final int _seat) {
        return new SyncBladeRequest&ls;Void&gt;() {
            @Override
            protected Void processSyncRequest() throws Exception {
                int leftFork = leftFork(_seat);
                int rightFork = rightFork(_seat);
                forkUsage[leftFork] = -1;
                forkUsage[rightFork] = -1;
                notice(leftSeat(leftFork));
                notice(rightSeat(rightFork));
                return null;
            }
        };
    }
</pre>
<p>
The ate request is received after a meal is eaten and the forks are no longer in use.
The forks are marked as available and notice is called for the left and right seat to see if any pending 
requests can be satisfied.
</p>
<pre>
    private void notice(final int _seat) throws Exception {
        AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[_seat];
        if (pendingResponse == null)
            return;
        if (!getForks(_seat))
            return;
        pendingResponses[_seat] = null;
        if (mealsEaten == meals)
            pendingResponse.processAsyncResponse(true);
        mealsEaten++;
        pendingResponse.processAsyncResponse(true);
    }
</pre>
<p>
If there is a pending request for the seat and both forks are acquired, then:
</p>
<ol>
<li>The seat is cleared of the pending response.</li>
<li>if there is no spaghetti remaining, then a response of false is passed back to the philosopher.</li>
<li>Otherwise the number of meals eaten is incremented by 1 and a response of true is passed back.</li>
</ol>
<h2>DiningRoom</h2>
</body>
</html>
