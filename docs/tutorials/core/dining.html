<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; DiningPhilosophers
</p>
<h1>DiningPhilosophers - Pending Responses</h1>
<p>
The <a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining Philosophers</a> 
is a classic problem in concurrency.
Five philosophers sit at a table with 5 place settings and 5 forks. 
Spaghetti is served, but the philosophers will only eat when they have two forks.
The philosophers, once they have both forks, will eat a meal and then return the forks to the table before eating again.
Our objective here is to see how fast our philosophers can eat.
</p>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Dining_philosophers.png/578px-Dining_philosophers.png"></a>
<h2>DiningPhilosopher</h2>
<p>
As we are implementing our solution to this problem without built-in delays or locks, we will use 
hungry philosophers who will eat as soon as they get both a left and right fork, put the forks back on the
table and then immediately try to pick up their forks and eat again. This differs a bit from other solutions where the philosophers
take time out to think when they can not immediately get a fork. 
<a href="DiningPhilosopher.java">Here</a> is the code used to model a hungry philosopher:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class DiningPhilosopher extends BladeBase {
    public DiningPhilosopher(final Reactor _reactor) throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;Integer&gt; feastAReq(final DiningTable _diningTable, final int _seat)
            throws Exception {
        return new AsyncBladeRequest&lt;Integer&gt;() {
            final AsyncResponseProcessor&lt;Integer&gt; dis = this;
            
            private int mealsEaten;
            private AsyncResponseProcessor&lt;Void&gt; ateResponseProcessor;
            private AsyncResponseProcessor&lt;Boolean&gt; eatResponseProcessor;
            
            @Override
            protected void processAsyncRequest() throws Exception {
                ateResponseProcessor = new AsyncResponseProcessor&lt;Void&gt;() {
                    @Override
                    public void processAsyncResponse(final Void _ateResponse) throws Exception {
                        AsyncRequest&lt;Boolean&gt; eatAReq = _diningTable.eatAReq(_seat);
                        send(eatAReq, eatResponseProcessor);
                    }
                };
                eatResponseProcessor = new AsyncResponseProcessor&lt;Boolean&gt;() {
                    @Override
                    public void processAsyncResponse(final Boolean _eatResponse) throws Exception {
                        if (!_eatResponse) {
                            dis.processAsyncResponse(mealsEaten);
                            return;
                        }
                        mealsEaten++;
                        SyncRequest&lt;Void&gt; ateSReq = _diningTable.ateSReq(_seat);
                        send(ateSReq, ateResponseProcessor);
                    }
                };
                AsyncRequest&lt;Boolean&gt; eatAReq = _diningTable.eatAReq(_seat);
                send(eatAReq, eatResponseProcessor);
            }
        };
    }
}
</pre>
<p>
Each philosopher has a seat at the table, and the seats are numbered from 0 through 4.
The DiningPhilosopher class implements a single public request, feastAReq, 
which returns the number of meals the philosopher ate once all the spaghetti was eaten.
</p>
<p>
The feast request executes a simple loop, calling eatAReq and ateSReq until eatAReq returns a result
of false--which indicates that there is no more food to eat.
</p>
<h2>DiningTable</h2>
<p>
The <a href="DiningTable.java">DiningTable</a> is responsible for managing the forks and serving up the spaghetti.
But it also does not respond to an eat request until either both forks are available or
there is no more spaghetti, whichever comes first.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class DiningTable extends BladeBase {
    public final int seats;
    public final int meals;
    
    private int mealsEaten;
    private int[] forkUsage;
    private AsyncResponseProcessor&lt;Boolean&gt;[] pendingResponses;

    public DiningTable(final Reactor _reactor, final int _seats, final int _meals) 
            throws Exception {
        initialize(_reactor);
        seats = _seats;
        meals = _meals;
        forkUsage = new int[seats];
        int i = 0;
        while (i < seats) {
            forkUsage[i] = -1;
            i++;
        }
        pendingResponses = new AsyncResponseProcessor[seats];
    }
    
    private int leftFork(final int _seat) {
        return _seat;
    }
    
    private int rightFork(final int _seat) {
        return (_seat + 1) % seats;
    }
    
    private boolean isForkAvailable(final int _seat) {
        return forkUsage[_seat] == -1;
    }
    
    private boolean getForks(final int _seat) {
        int leftFork = leftFork(_seat);
        int rightFork = rightFork(_seat);
        if (isForkAvailable(leftFork) && isForkAvailable(rightFork)) {
            forkUsage[leftFork] = _seat;
            forkUsage[rightFork] = _seat;
            return true;
        }
        return false;
    }
    
    public AsyncRequest&lt;Boolean&gt; eatAReq(final int _seat) {
        return new AsyncBladeRequest&lt;Boolean&gt;() {
            final AsyncResponseProcessor&lt;Boolean&gt; dis = this;
            
            @Override
            protected void processAsyncRequest() throws Exception {
                if (mealsEaten == meals) {
                    dis.processAsyncResponse(false);
                    return;
                }
                
                if (getForks(_seat)) {
                    chowTime(_seat);
                    dis.processAsyncResponse(true);
                    return;
                }
                
                pendingResponses[_seat] = dis;
            }
        };
    }
    
    private void chowTime(final int _seat) throws Exception {
        mealsEaten++;
        if (mealsEaten == meals) {
            int i = 0;
            while (i < seats) {
                AsyncResponseProcessor<Boolean> pendingResponse = pendingResponses[i];
                if (pendingResponse != null) {
                    pendingResponse.processAsyncResponse(false);
                }
                i++;
            }
        }
    }
    
    private int leftSeat(final int _fork) {
        return (_fork + seats - 1) % seats;
    }
    
    private int rightSeat(final int _fork) {
        return _fork;
    }

    private void notice(final int _seat) throws Exception {
        AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[_seat];
        if (pendingResponse == null)
            return;
        if (!getForks(_seat))
            return;
        pendingResponses[_seat] = null;
        if (mealsEaten < meals) {
            chowTime(_seat);
            pendingResponse.processAsyncResponse(true);
        }
    }
    
    public SyncRequest&lt;Void&gt; ateSReq(final int _seat) {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            protected Void processSyncRequest() throws Exception {
                int leftFork = leftFork(_seat);
                int rightFork = rightFork(_seat);
                forkUsage[leftFork] = -1;
                forkUsage[rightFork] = -1;
                notice(leftSeat(leftFork));
                notice(rightSeat(rightFork));
                return null;
            }
        };
    }
}
</pre>
<h3>eatAReq</h3>
<pre>
    public AsyncRequest&lt;Boolean&gt; eatAReq(final int _seat) {
        return new AsyncBladeRequest&lt;Boolean&gt;() {
            final AsyncResponseProcessor&lt;Boolean&gt; dis = this;
            
            @Override
            protected void processAsyncRequest() throws Exception {
                if (mealsEaten == meals) {
                    dis.processAsyncResponse(false);
                    return;
                }
                
                if (getForks(_seat)) {
                    chowTime(_seat);
                    dis.processAsyncResponse(true);
                    return;
                }
                
                pendingResponses[_seat] = dis;
            }
        };
    }
</pre>
<p>
When an eat request is received but there are no more meals to serve, 
a response of false is passed back.
</p>
<p>
If there are more meals remaining and both forks are acquired, then
call the chowTime method and a response of true is passed back to the requesting philosopher.
<p>
Otherwise, the response is left pending until either there is no more spaghetti or both forks become available.
</p>
<pre>    
    private void chowTime(final int _seat) throws Exception {
        mealsEaten++;
        if (mealsEaten == meals) {
            int i = 0;
            while (i < seats) {
                AsyncResponseProcessor<Boolean> pendingResponse = pendingResponses[i];
                if (pendingResponse != null) {
                    pendingResponse.processAsyncResponse(false);
                }
                i++;
            }
        }
    }
</pre>
The chowTime method increments the number of meals eaten by 1.
Then if all the meals have been eaten, the pending philosophers are passed back a false.
<h3>ateSReq</h3>
<pre>
    public SyncRequest&lt;Void&gt; ateSReq(final int _seat) {
        return new SyncBladeRequest&lt;Void&gt;() {
            @Override
            protected Void processSyncRequest() throws Exception {
                int leftFork = leftFork(_seat);
                int rightFork = rightFork(_seat);
                forkUsage[leftFork] = -1;
                forkUsage[rightFork] = -1;
                notice(leftSeat(leftFork));
                notice(rightSeat(rightFork));
                return null;
            }
        };
    }
</pre>
<p>
The ate request is received after a meal is eaten and the forks are no longer in use.
The forks are marked as available and notice is called for the left and right seat to see if any pending 
requests can be satisfied.
</p>
<pre>
    private void notice(final int _seat) throws Exception {
        AsyncResponseProcessor&lt;Boolean&gt; pendingResponse = pendingResponses[_seat];
        if (pendingResponse == null)
            return;
        if (!getForks(_seat))
            return;
        if (mealsEaten < meals) {
            pendingResponses[_seat] = null;
            chowTime(_seat);
            pendingResponse.processAsyncResponse(true);
        }
    }
</pre>
<p>
If there is a pending request for the seat, both forks are acquired and there is some food left, then
clear the pending request, call the chowTime method and pass true back to the pending philosopher.
</p>
<h2>DiningRoom</h2>
<p>
The <a href="DiningRoom.java">DiningRoom</a> class creates the dining table and the philosophers and invites the philosophers
to the feast. When all the meals have been eaten, the dining room validates and reports the result.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.blades.misc.SyncPrinterRequest;
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.facilities.Plant;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.IsolationReactor;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;
import org.agilewiki.jactor2.core.reactors.Reactor;

import java.util.Iterator;
import java.util.List;
import java.util.LinkedList;

public class DiningRoom extends BladeBase {
    public DiningRoom(final Reactor _reactor)
            throws Exception {
        initialize(_reactor);
    }
    
    public AsyncRequest&lt;List&lt;Integer&gt;&gt; feastAReq(final int _seats, final int _meals)
            throws Exception {
        return new AsyncBladeRequest&lt;List&lt;Integer&gt;&gt;() {
            final AsyncResponseProcessor&lt;List&lt;Integer&gt;&gt; dis = this;
            List&lt;Integer&gt; mealsEaten = new LinkedList&lt;Integer&gt;();
            
            AsyncResponseProcessor&lt;Integer&gt; feastResponseProcessor =
                new AsyncResponseProcessor&lt;Integer&gt;() {
                    @Override
                    public void processAsyncResponse(final Integer _feastResponse) 
                            throws Exception {
                        mealsEaten.add(_feastResponse);
                        if (mealsEaten.size() == _seats) {
                            dis.processAsyncResponse(mealsEaten);
                        }
                    }
            };
            
            @Override
            protected void processAsyncRequest() throws Exception {
                int i = 0;
                Reactor myReactor = getReactor();
                Facility facility = myReactor.getFacility();
                DiningTable diningTable = new DiningTable(
                    new NonBlockingReactor(facility),
                    _seats,
                    _meals);
                while (i < _seats) {
                    DiningPhilosopher diningPhilosopher =
                        new DiningPhilosopher(new NonBlockingReactor(facility));
                    AsyncRequest&lt;Integer&gt; feastAReq = diningPhilosopher.feastAReq(diningTable, i);
                    send(feastAReq, feastResponseProcessor);
                    ++i;
                }
            }
        };
    }
    
    public static SyncRequest<Void> report(
            final Printer _printer, 
            final int _seats, 
            final int _meals, 
            final List&lt;Integer&gt; _mealsEaten, 
            final long _duration) {
        return new SyncPrinterRequest(_printer) {
            @Override
            protected Void processSyncRequest() throws Exception {
                printf("Seats: %,d%n", _seats);
                printf("Meals: %,d%n", _meals);
                println("\nMeals eaten by each philosopher:");
                Iterator&lt;Integer&gt; it = _mealsEaten.iterator();
                int totalEaten = 0;
                while (it.hasNext()) {
                    int me = it.next();
                    totalEaten += me;
                    if (_mealsEaten.size() < 11)
                        printf("    %,d%n", me);
                }
                if (totalEaten != _meals)
                    throw new IllegalStateException("total meals eaten does not match: " + totalEaten);
                printf("\nTest duration in nanoseconds: %,d%n", _duration);
                if (_duration > 0) {
                    printf("Total meals eaten per second: %,d%n%n", 1000000000L * _meals / _duration);
                }
                return null;
            }
        };
    }
    
    public static void main(String[] args) throws Exception {
        int seats = 5;
        int meals = 1000000;
        Plant plant = new Plant();
        try {
            NonBlockingReactor diningRoomReactor = new NonBlockingReactor(plant);
            DiningRoom diningRoom = new DiningRoom(diningRoomReactor);
            AsyncRequest&lt;List&lt;Integer&gt;&gt; feastAReq = diningRoom.feastAReq(seats, meals);
            long before = System.nanoTime();
            List&lt;Integer&gt; mealsEaten = feastAReq.call();
            long after = System.nanoTime();
            long duration = after - before;
            Printer printer = new Printer(new IsolationReactor(plant));
            report(printer, seats, meals, mealsEaten, duration).call();
        } finally {
            plant.close();
        }
    }
}
</pre>
<h3>feastAReq</h3>
<p>
The dining room implements a feast request, which creates the dining table and the philosophers
and sends a feast request to all the philosophers. The result returned is a list of the number of
meals eaten by each philosopher.
</p>
<pre>
    public AsyncRequest&lt;List&lt;Integer&gt;&gt; feastAReq(final int _seats, final int _meals)
            throws Exception {
        return new AsyncBladeRequest&lt;List&lt;Integer&gt;&gt;() {
            final AsyncResponseProcessor&lt;List&lt;Integer&gt;&gt; dis = this;
            List&lt;Integer&gt; mealsEaten = new LinkedList&lt;Integer&gt;();
            
            AsyncResponseProcessor&lt;Integer&gt; feastResponseProcessor =
                new AsyncResponseProcessor&lt;Integer&gt;() {
                    @Override
                    public void processAsyncResponse(final Integer _feastResponse) 
                            throws Exception {
                        mealsEaten.add(_feastResponse);
                        if (mealsEaten.size() == _seats) {
                            dis.processAsyncResponse(mealsEaten);
                        }
                    }
            };
            
            @Override
            protected void processAsyncRequest() throws Exception {
                int i = 0;
                Reactor myReactor = getReactor();
                Facility facility = myReactor.getFacility();
                DiningTable diningTable = new DiningTable(
                    new NonBlockingReactor(facility),
                    _seats,
                    _meals);
                while (i < _seats) {
                    DiningPhilosopher diningPhilosopher =
                        new DiningPhilosopher(new NonBlockingReactor(facility));
                    AsyncRequest&lt;Integer&gt; feastAReq = diningPhilosopher.feastAReq(diningTable, i);
                    send(feastAReq, feastResponseProcessor);
                    ++i;
                }
            }
        };
    }
</pre>
<p>
As each philosopher finish the feast, the number of meals eaten by that philosopher is added
to the list of meals eaten. And when the last philosopher finishes, the list is passed back as the result of the
dining room feast.
</p>
<h3>Performance</h3>
<pre>
Output:

Seats: 5
Meals: 1,000,000

Meals eaten by each philosopher:
    157,930
    331,681
    174,580
    152,758
    183,051

Test duration in nanoseconds: 1,425,761,890
Total meals eaten per second: 701,379
</pre>
</body>
</html>
