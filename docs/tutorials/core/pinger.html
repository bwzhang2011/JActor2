<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Pinger
</p>
<h1>Pinger - Send Methods per Second</h1>
<p>
The <a href="Pinger.java">Pinger</a> blade is a minor variation on the Loop blade that uses Ponger instead of Printer.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class Pinger extends BladeBase {
    private final Ponger ponger;

    public Pinger(final Reactor _reactor, final Ponger _ponger) throws Exception {
        initialize(_reactor);
        ponger = _ponger;
    }

    public AsyncRequest&lt;Void&gt; loopAReq(final long _count) {
        return new AsyncBladeRequest&lt;Void&gt;() {
            final AsyncResponseProcessor&lt;Void&gt; dis = this;
            long i = 0;

            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {

                @Override
                public void processAsyncResponse(final Long _response) throws Exception {
                    iterate();
                }
            };

            @Override
            protected void processAsyncRequest() throws Exception {
                iterate();
            }
            
            public void iterate() throws Exception {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                i++;
                SyncRequest&lt;Long&gt; ping = ponger.pingSReq();
                send(ping, pingResponseProcessor);
            }
        };
    }
}
</pre>
<h3>
ReactorSendSpeedReport
</h3>
<p>
The speed of send depends largely on the relationship between the originating and target blades.
We will first look at the case where the two blades share the same reactor.
In this case, the local method should be used if the request being sent is a SyncRequest and
it is known that the blades share a reactor. But this is not always the case.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.IsolationReactor;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class ReactorSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 100000000L;
        Facility facility = new Facility();
        try {
            NonBlockingReactor sharedReactor = new NonBlockingReactor(facility);
            Ponger ponger = new Ponger(sharedReactor);
            Pinger pinger = new Pinger(sharedReactor, ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            Printer printer = new Printer(new IsolationReactor(facility));
            SpeedReport.startSReq(printer, "Reactor Send Timings", duration, count).call();
        } finally {
            facility.close();
        }
    }
}

Output:

Reactor Send Timings
Test duration in nanoseconds: 4,512,364,097
Number of exchanges: 100,000,000
Exchanges per second: 22,161,332</pre>
<p>
This is a bit slower than when using the local method, but then asynchronous processing has a bit more overhead:
</p>
<pre>
Local Timings
Test duration in nanoseconds: 5,764,216,729
Number of exchanges: 500,000,000
Exchanges per second: 86,742,054
</pre>
</body>
</html>
