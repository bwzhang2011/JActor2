<html>
<body>
<p>
<a href="https://github.com/laforge49/JActor2#readme">JActor2</a> &gt; <a href="../../index.html">Docs</a> &gt; <a href="../index.html">Tutorials</a> &gt; <a href="index.html">Core</a> &gt; Pinger
</p>
<h1>Pinger - Send Methods per Second</h1>
<p>
The <a href="Pinger.java">Pinger</a> blade is a minor variation on 
the <a href="loop.html">Loop</a> blade that uses <a href="ponger.html">Ponger</a> instead of Printer.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.BladeBase;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.messages.AsyncResponseProcessor;
import org.agilewiki.jactor2.core.messages.SyncRequest;
import org.agilewiki.jactor2.core.reactors.Reactor;

public class Pinger extends BladeBase {
    private final Ponger ponger;

    public Pinger(final Reactor _reactor, final Ponger _ponger) throws Exception {
        initialize(_reactor);
        ponger = _ponger;
    }

    public AsyncRequest&lt;Void&gt; loopAReq(final long _count) {
        return new AsyncBladeRequest&lt;Void&gt;() {
            final AsyncResponseProcessor&lt;Void&gt; dis = this;
            long i = 0;

            final AsyncResponseProcessor&lt;Long&gt; pingResponseProcessor = 
                    new AsyncResponseProcessor&lt;Long&gt;() {

                @Override
                public void processAsyncResponse(final Long _response) throws Exception {
                    iterate();
                }
            };

            @Override
            protected void processAsyncRequest() throws Exception {
                iterate();
            }
            
            public void iterate() throws Exception {
                if (i >= _count) {
                    dis.processAsyncResponse(null);
                    return;
                }
                i++;
                SyncRequest&lt;Long&gt; ping = ponger.pingSReq();
                send(ping, pingResponseProcessor);
            }
        };
    }
}
</pre>
<h3>
ReactorSendSpeedReport
</h3>
<p>
The speed of send depends largely on the relationship between the originating and target blades.
We will first look at the case where the two blades share the same reactor.
In this case, the local method should be used if the request being sent is a SyncRequest and
it is known that the blades share a reactor. But this is not always the case.
</p>
<pre>
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class ReactorSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 100000000L;
        Facility facility = new Facility();
        try {
            NonBlockingReactor sharedReactor = new NonBlockingReactor(facility);
            Ponger ponger = new Ponger(sharedReactor);
            Pinger pinger = new Pinger(sharedReactor, ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.startAReq(facility, "Reactor Send Timings", duration, count).call();
        } finally {
            facility.close();
        }
    }
}

Output:

Reactor Send Timings
Test duration in nanoseconds: 4,512,364,097
Number of exchanges: 100,000,000
Exchanges per second: 22,161,332</pre>
<p>
This is a bit slower than when using the local method, but then asynchronous processing has a bit more overhead:
</p>
<pre>
Local Timings
Test duration in nanoseconds: 5,764,216,729
Number of exchanges: 500,000,000
Exchanges per second: 86,742,054
</pre>
<h3>
FacilitySendSpeedReport
</h3>
<p>
A very common case is sending a request between two blades with different reactors that are a part of the same facility:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class FacilitySendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 10000000L;
        Facility facility = new Facility();
        try {
            Ponger ponger = new Ponger(new NonBlockingReactor(facility));
            Pinger pinger = new Pinger(new NonBlockingReactor(facility), ponger);
            AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
            final long before = System.nanoTime();
            loopAReq.call();
            final long after = System.nanoTime();
            final long duration = after - before;
            SpeedReport.startAReq(facility, "Facility Send Timings", duration, count).call();
        } finally {
            facility.close();
        }
    }
}
</pre>
<p>
In this case the send is, as you would expect, much slower than when the two blades use a common reactor:
</p>
<pre>
Facility Send Timings
Test duration in nanoseconds: 4,351,072,002
Number of exchanges: 10,000,000
Exchanges per second: 2,298,284
</pre>
<p>
Even slow, a send between two blades with different reactors but part of the same facility is
much faster than when using a call method from a non-pool thread:
</p>
<pre>
Call Timings
Test duration in nanoseconds: 5,173,229,782
Number of exchanges: 1,000,000
Exchanges per second: 193,302
</pre>
<h3>
JvmSendSpeedReport
</h3>
<p>
Sending requests between blades that are parts of different facilities is far less common:
</p>
<pre>
import org.agilewiki.jactor2.core.blades.misc.Printer;
import org.agilewiki.jactor2.core.facilities.Facility;
import org.agilewiki.jactor2.core.messages.AsyncRequest;
import org.agilewiki.jactor2.core.reactors.IsolationReactor;
import org.agilewiki.jactor2.core.reactors.NonBlockingReactor;

public class JvmSendSpeedReport {
    public static void main(final String[] _args) throws Exception {
        final long count = 1000000L;
        Facility facility1 = new Facility();
        try {
            Facility facility2 = new Facility();
            try {
                Ponger ponger = new Ponger(new NonBlockingReactor(facility1));
                Pinger pinger = new Pinger(new NonBlockingReactor(facility2), ponger);
                AsyncRequest&lt;Void&gt; loopAReq = pinger.loopAReq(count);
                final long before = System.nanoTime();
                loopAReq.call();
                final long after = System.nanoTime();
                final long duration = after - before;
                SpeedReport.startAReq(facility1, "JVM Send Timings", duration, count).call();
            } finally {
                facility2.close();
            }
        } finally {
            facility1.close();
        }
    }
}
</pre>
<p>
In this case the send is even a bit slower than using the call method, due to complications arising from the
fact that facilities each have their own independent lifecycle:
</p>
<pre>
JVM Send Timings
Test duration in nanoseconds: 7,052,639,750
Number of exchanges: 1,000,000
Exchanges per second: 141,790
</pre>
</body>
</html>
